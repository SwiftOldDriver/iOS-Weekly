# 老司机 iOS 周报 #364 | 2026-02-09

![ios-weekly](https://github.com/SwiftOldDriver/iOS-Weekly/blob/master/assets/weekly-header/364.jpg?raw=true)

在各位读者们的陪伴下老司机技术又度过了一年春秋，这一年大模型的发展出乎意料的快，我们也添加了不少相关的实践与经验，拥抱大模型享受红利也是大势所趋。下一期我们的相见就在年后了，老司机的编辑们给大家拜年了，新春快乐！

老司机 iOS 周报，只为你呈现有价值的信息。

你也可以为这个项目出一份力，如果发现有价值的信息、文章、工具等可以到 [Issues](https://github.com/SwiftOldDriver/iOS-Weekly/issues) 里提给我们，我们会尽快处理。记得写上推荐的理由哦。有建议和意见也欢迎到 [Issues](https://github.com/SwiftOldDriver/iOS-Weekly/issues) 提出。

## 新闻

> 行业相关的新闻、趣事、看法

##  Developer - 设计开发加速器

> 设计开发加速器相关活动

## 新手推荐

> 收集一些对新手友好且质量不错的文章

## 文章

> 写的不错的技术博客，包含但不局限于 iOS、多端统一、设计、产品等

### 🐕 [The Magic Behind UUID\(\) in Swift, How Your App Generates Truly Unique Identifiers](https://www.swiftdifferently.com/blog/swift/the-magic-behind-uuid-in-swift)

[@Barney](https://github.com/BarneyZhaoooo)：本文介绍 Swift 中 UUID () 的原理与特性，默认生成 Version 4 随机 UUID。它基于 122 位加密安全随机数，从硬件、系统等多源收集熵值，经 CSPRNG 处理，按 RFC 4122 格式化，唯一性几乎绝对。还提及 Version 1（时间 + MAC 地址）和 Version 7（时间 + 随机），并说明 UUID 高效且无碰撞顾虑。

### 🐕 [Swift Modules and Code/Assets Duplication](https://pfandrade.me/blog/swift-modules-and-codeassets-duplication/)
[@Smallfly](https://github.com/iostalks)：这篇文章针对 Swift 模块化开发中的代码与资源重复问题，提供了简洁高效的解决方案。核心内容包括：

- **模块化痛点**：使用 Swift Package 拆分模块后，静态链接导致代码在主应用与扩展（如 Action Extension）中重复；资源文件（图片、本地化字符串等）会生成独立 bundle 并被复制到每个依赖 target，增加包体积。
- **代码去重**：创建动态框架聚合所有模块，通过 `Package.swift` 配置动态库目标，让主应用与扩展依赖该框架，避免代码重复链接。
- **资源去重**：利用 Run Script 脚本将模块资源 bundle 移动到动态框架内，删除主应用与扩展中的重复 bundle；结合 `Bundle.module` 的查找逻辑，确保资源访问路径正确。

文章通过具体代码示例与目录结构对比，展示了优化前后的效果，为 Swift 开发者解决模块化带来的包体积问题提供了可落地的实践方案。

### [Attach to Multiple Processes](https://indiestack.com/2025/11/attach-to-multiple-processes/)

[@ChengzhiHuang](https://github.com/ChengzhiHuang)：调试工作通常只涉及单个主应用进程。但随着 App Extension、XPC 服务以及更复杂的 macOS 应用架构变得普遍，我们偶尔需要同时关注多个进程。然而 Xcode 在这方面的支持却不尽如人意：它能自动 attach 到你构建的 XPC 服务，但对于非 XPC 的子进程或多个同名进程实例，就显得力不从心，需要手动逐一操作，效率低下。对此作者提供了一个脚本查找所有指定名称的进程，并让 Xcode 的调试器一次性全部 attach 到它们上面。适合有特定需求的同学阅读。

### 🐎 [How to Avoid Double Updates When Filtering SwiftUI TextField Input](https://livsycode.com/swiftui/how-to-avoid-double-updates-when-filtering-swiftui-textfield-input/)

[@阿权](https://github.com/bqlin)：文章为文本输入组件的文字 filter 提供了通用的解决方案。本文核心解决 SwiftUI TextField 过滤输入时的 “双重更新” 问题，核心思路封过滤/转换逻辑，以解耦上下游逻辑。具体思路如下：

1. 内部缓冲区隔离，引入 “内部缓冲区（internalText）” 与 “外部绑定（text）” 分离的设计：
   1. 用户输入路径：键盘输入 → 内部缓冲区 → 过滤 / 转换 → 同步到外部绑定（仅有效值）；
   2. 外部更新路径：外部绑定修改 → 过滤 / 转换 → 同步到内部缓冲区（确保 UI 一致）；
2. 注意事项：
   1. 光标位置：编程修改文本可能导致光标重置，复杂场景需适配；
   2. 转换规则：需保证确定性和幂等性，避免同步循环。

### 🐎 [Understanding Spring Animations in SwiftUI](https://www.createwithswift.com/understanding-spring-animations-in-swiftui/)

[@含笑饮砒霜](https://weibo.com/chinafishnews/)：这篇文章讲解 SwiftUI 中的弹簧动画，说明其模拟物理运动、适配用户直接交互的特性，优于 easeInOut 等动画；介绍了该动画的默认用法、响应速度和阻尼系数两个可调参数，withAnimation 和.animation (_:value:) 两种触发方式，以及手势适配的.interactiveSpring () 修饰符，并结合实操案例展示应用，同时明确其适用于用户触发的操作，加载类自动界面变化则更适合线性 / 缓入缓出动画，强调其能提升应用的交互体验。

### 🐎 [InlineArray in Swift - Memory Efficient Fixed-Size Arrays](https://www.sagarunagar.com/blog/inlinearray-in-swift/)

[@JonyFang](https://github.com/jonyfang):本文介绍了 Swift 6.2 新增的 InlineArray 类型，一种固定大小、值类型的内联数组。与标准 Array 的堆分配不同，InlineArray 将元素直接存储在值内部，消除了堆分配、引用计数和指针间接访问的开销。核心要点：

- 声明与约束：大小是类型的一部分（如 InlineArray<Int, 4>），编译期即确定容量，必须提供恰好该数量的元素，不可 append 或 remove，提供强编译期保证。
- 性能优势：元素连续内联存储，无需指针追踪，CPU 缓存命中率更高，适合数学运算、几何类型、小型缓冲区及框架内部结构等场景。
- 实际应用：文章以 3D 向量为例，将 var values: [Float] 替换为 InlineArray<Float, 3>，在语义更清晰的同时实现零堆分配。支持标准 for-in 迭代，也可通过 Array(inline) 转换为普通数组。
- 适用边界：适合小型固定集合、性能关键路径和框架内部实现；不适合需要 append()、filter()、map() 等动态操作的场景。文章强调 InlineArray 是专用工具而非通用集合，日常应用代码仍推荐标准 Array。

### 🐕 [Should You Use All These Dependencies?](https://fractal-dev.com/blog/should-you-use-all-these-dependencies?lang=en)

[@Barney](https://github.com/BarneyZhaoooo)：从 iOS 项目依赖选择角度出发，作者以项目中仅用到 3 处 RxSwift 却引入 3MB 体积与编译成本为例，讨论“能不用库就不用”的默认立场。核心内容包括：

- **决策标准**：评估收益、迁移成本、团队熟悉度与长期维护负担，避免因熟悉而引入不必要抽象
- **案例对比**：以 Alamofire vs URLSession 说明第三方并非总是更省时，功能范围与实际需求应匹配
- **风险控制**：建议使用 Wrapper/Facade、版本锁定与定期依赖审计（工具 + 清单）降低锁定与弃坑风险

最后强调每个依赖都是“当下效率”与“未来债务”的权衡，适合建立团队的依赖准入与清理流程。

### 🐕 [How Apple Hooks Entire Frameworks](https://bryce.co/swizzle-everything/)

[@Kyle-Ye](https://github.com/Kyle-Ye): 文章深入分析了 Apple 如何通过 Method Swizzling 实现对整个框架的 hook，以 Main Thread Checker 为例，展示了其如何大规模替换数万个方法。作者介绍了基于 trampoline 的实现方案——为每个被 hook 的方法生成唯一的跳板函数，通过共享的汇编处理程序保存和恢复寄存器状态，再调用统一的回调。文章还探讨了如何通过运行时内存映射动态创建 trampoline 以突破数量限制，以及使用私有 API `class_replaceMethodsBulk` 批量替换方法以减少锁竞争从而提升性能。对于对 Objective-C Runtime 底层机制和性能优化感兴趣的开发者值得一读。

### 🐕 [Exploring AI Driven Coding: Using Xcode 26.3 MCP Tools in Cursor, Claude Code and Codex](https://rudrank.com/exploring-xcode-using-mcp-tools-cursor-external-clients)

[@zhangferry](zhangferry.com)：Xcode 26.3 带来一项重要更新：官方通过 `xcrun mcpbridge` 桥接工具，向外部 MCP 客户端开放了 20 个原生工具接口。这一举措相较苹果以往的产品策略，显得尤为开放。其核心交互机制为：外部 MCP 客户端（如 Cursor、Claude Code）<-> mcpbridge 桥接工具 <-> Xcode（基于 XPC 通信）。

该功能依托 Xcode 内部运行的 MCP 服务实现，第三方智能代理（Agent）可通过这一链路调用 Xcode 的 MCP 能力，所以该功能无法脱离 Xcode 独立运行。在开放的工具中，除基础的文件读取类工具外，以下几款实用工具值得关注：

* BuildProject：构建工程，可快速验证工程代码的可编译性；
* GetBuildLog：获取构建日志，助力优化构建流程，也可用于排查构建环节的潜在问题；
* XcodeListNavigatorIssues：提取 Xcode 导航栏中展示的各类 issue 或 error 信息，便于快速定位代码问题；
* RenderPreview：将 SwiftUI 预览界面渲染为图片文件，直观预览 UI 效果；
* ExecuteSnippet：实时执行代码片段，可快速验证小段代码的执行逻辑与结果。

## 工具

### [steve](https://github.com/mikker/steve)

[@EyreFree](https://github.com/EyreFree)：steve 是基于 macOS 无障碍 API 开发的命令行工具，主打 Mac 应用的自动化操控，适用于自动化测试与 AI 代理控制场景。它支持通过命令完成应用的启动、聚焦、退出等基础管理，还能发现和定位应用界面元素，实现点击、输入、快捷键触发等交互操作，亦可对窗口、菜单栏进行操控，以及截取应用或指定元素的截图。工具默认输出结构化文本，也支持 JSON 格式，提供断言、等待等可靠性辅助功能，能通过 stderr 反馈错误。对 Mac 端应用自动化操作有需要的同学可以试试。

## 代码

> 库，代码段，开源app

## 书

> 比较不错的书的推荐和书评

## 音视频

> 比较不错的书的推荐和书评

## 内推

重新开始更新「iOS 靠谱内推专题」，整理了最近明确在招人的岗位，供大家参考

具体信息请移步：https://www.yuque.com/iosalliance/article/bhutav 进行查看（如有招聘需求请联系 iTDriverr）

## 关注我们

我们是「老司机技术周报」，一个持续追求精品 iOS 内容的技术公众号，欢迎关注。

**关注有礼，关注【老司机技术周报】，回复「2024」，领取 2024 及往年内参**

![](https://github.com/SwiftOldDriver/iOS-Weekly/blob/master/assets/qrcode_for_wechat.jpg?raw=true)

同时也支持了 RSS 订阅：https://github.com/SwiftOldDriver/iOS-Weekly/releases.atom 。

## 说明

🚧 表示需某工具，🌟 表示编辑推荐

预计阅读时间：🐎 很快就能读完（1 - 10 mins）；🐕 中等 （10 - 20 mins）；🐢 慢（20+ mins）
